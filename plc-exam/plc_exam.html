<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PLC等级理论考试</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; background: #fafafa; min-height: 100vh; display: flex; flex-direction: column; }
    header { background-color: #3f51b5; color: white; padding: 16px; text-align: center; font-size: 1.2rem; flex-shrink: 0; }
    nav { display: flex; background-color: #f5f5f5; border-bottom: 1px solid #ddd; flex-shrink: 0; }
    nav button { flex: 1; padding: 14px 0; border: none; background: none; font-size: 1rem; cursor: pointer; }
    nav button.active { border-bottom: 3px solid #3f51b5; font-weight: bold; background-color: #e0e0e0; }
    #content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      padding-bottom: 100px;
    }
    .question-container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .question-header { display: flex; align-items: center; margin-bottom: 10px; }
    .badge { display: inline-block; background-color: #e53935; color: white; border-radius: 12px; padding: 2px 6px; margin-right: 8px; font-size: 0.75rem; }
    .options { margin-bottom: 12px; }
    .option { margin-bottom: 8px; line-height: 1.4; }
    .option input[type="radio"], .option input[type="checkbox"] { margin-right: 8px; }
    .feedback { margin-top: 10px; font-weight: bold; }
    .feedback.correct { color: #388e3c; }
    .feedback.incorrect { color: #e53935; }
    .bottom-bar { position: fixed; bottom: 0; left: 0; right: 0; background: #f5f5f5; border-top: 1px solid #ddd; padding: 10px 16px; display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; }
    .bottom-bar button { margin-left: 8px; padding: 6px 12px; border: 1px solid #3f51b5; border-radius: 4px; background: #3f51b5; color: white; cursor: pointer; font-size: 0.9rem; }
    .bottom-bar button:hover { opacity: 0.9; }
    .hidden { display: none; }
    @media (max-width: 600px) {
      .bottom-bar { flex-direction: column; align-items: flex-start; }
      .bottom-bar > div + div { margin-top: 8px; width: 100%; display: flex; justify-content: flex-start; flex-wrap: wrap; gap: 8px; }
      .bottom-bar button { margin-left: 0; flex: 1 1 auto; }
    }
    #signature-area { text-align: center; padding: 16px; }
    #signature-area img { max-width: 120px; display: block; margin: 8px auto; }
    #top-actions { display: flex; justify-content: center; align-items: center; gap: 8px; padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; flex-wrap: wrap; }
    #top-actions button { padding: 6px 12px; font-size: 0.9rem; border: 1px solid #3f51b5; background: #3f51b5; color: #fff; border-radius: 4px; cursor: pointer; }
    #top-actions button:hover { opacity: 0.9; }
    .buttons button { padding: 8px 16px; font-size: 1rem; margin-right: 8px; border: 1px solid #3f51b5; background: #3f51b5; color: #fff; border-radius: 4px; cursor: pointer; }
    .buttons button:last-child { margin-right: 0; }
    .buttons button:hover { opacity: 0.9; }

    /* NEW: Update list styles */
    #update-area {
      background: #fffbe6;
      border: 1px solid #ffe58f;
      padding: 12px 16px;
      margin: 12px auto;
      max-width: 800px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    #update-area.hidden {
      display: none;
    }
    #update-area h3 {
      margin-top: 0;
    }
    #update-area ul {
      padding-left: 20px;
      margin: 8px 0 0 0;
    }
    #update-area ul li {
      line-height: 1.6;
    }

    /* --- NEW: History Page Styles --- */
    .history-container { max-width: 800px; margin: 0 auto; }
    .history-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .history-header h2 { margin: 0; }
    .history-entry { background: #fff; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
    .history-entry summary { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; font-weight: normal; cursor: pointer; list-style: none; }
    .history-entry summary::-webkit-details-marker { display: none; }
    .history-entry summary .summary-info { display: flex; flex-direction: column; }
    .history-entry summary .summary-info .info-main { font-weight: bold; color: #333; }
    .history-entry summary .summary-info .info-sub { font-size: 0.85rem; color: #757575; margin-top: 4px; }
    .history-details { padding: 12px 16px 16px 16px; border-top: 1px solid #eee; }
    .history-details ul { padding-left: 20px; margin: 0; }
    .history-details li { margin-bottom: 4px; color: #555; }
    .delete-btn { background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 4px; font-size: 0.8rem; cursor: pointer; }
    .delete-btn:hover { opacity: 0.85; }
    #clearHistoryBtn { background-color: #f44336; border-color: #f44336; }
    /* --- End of New Styles --- */

  </style>
</head>
<body>
  <header>
    <h1>PLC等级理论考试</h1>
  </header>
  <nav>
    <button id="tabQuiz" class="active">答题区</button>
    <button id="tabWrong">错题本</button>
  </nav>
  <div id="top-actions">
    </div>
  <!-- NEW: Updates list that appears only on the home page -->
  <div id="update-area">
    <h3>最近更新动态</h3>
    <ul>
      <li>历史记录可以继续之前未完成的答题任务</li>
      <li>主页移除了答题区域</li>
      <li>增加自定义区间顺序乱序答题</li>
      <li>增加上一题功能</li>
      <li>本模板开源地址https://github.com/Vyenkor/test上(使用请点亮star)</li>
      <li>网页将会在11月15日后失效如有答题需要请自行导入题库使用模板</li>
    </ul>
  </div>
  <div id="signature-area">
    <p>vyen</p>
    <img src="https://youke1.picui.cn/s1/2025/10/04/68e0e8a9ae986.jpg" alt="二维码">
    <p>请为我点赞</p>
  </div>
  <!-- Initially hide the content area so only the mode buttons and signature show until a practice session starts -->
  <div id="content" class="hidden"></div>
  <div class="bottom-bar">
    <div id="progress">&nbsp;</div>
  </div>
  <script src="plc_questions_data.js"></script>
  <script>
    (function() {
      const questions = window.plcQuestionsData;
      let mode = 'quiz';
      let order = questions.map((_, idx) => idx);
      let currentIndex = 0;
      let wrongOrder = [];
      let wrongIndex = 0;
      let wrongCounts = JSON.parse(localStorage.getItem('plc1_wrongCounts') || '{}');
      function updateWrongOrder() {
        wrongOrder = Object.keys(wrongCounts).filter(key => wrongCounts[key] > 0).map(num => {
          return questions.findIndex(q => q.number === parseInt(num));
        }).filter(idx => idx !== -1);
      }
      updateWrongOrder();
      const contentEl = document.getElementById('content');
      const progressEl = document.getElementById('progress');
      const tabQuizBtn = document.getElementById('tabQuiz');
      const tabWrongBtn = document.getElementById('tabWrong');
      const topActionsEl = document.getElementById('top-actions');
      const updateArea = document.getElementById('update-area');
      
      // Original top actions for starting different practice modes. A new “完整刷题” button is added for sequential practice through the entire question bank.
      const originalTopActionsHTML = `
        <button id="shuffleBtn">随机打乱</button>
        <button id="random50Btn">随机50题</button>
        <button id="random100Btn">随机100题</button>
        <button id="fullBtn">完整刷题</button>
        <button id="intervalSequentialBtn">区间顺序</button>
        <button id="intervalRandomBtn">区间随机</button>
        <button id="historyBtn">历史记录</button>
      `;

      let sessionOrder = [];
      let sessionCurrentIndex = 0;
      let sessionSize = 0;
      let sessionWrong = [];
      let sessionName = '';
      let sessionHistory = JSON.parse(localStorage.getItem('plc1_sessionHistory') || '[]');

      // When a user resumes a session from history, this index will point to the entry in sessionHistory being resumed.
      // It is null for new sessions. During resumed sessions the history entry is updated as questions are answered.
      let currentHistoryResumeIndex = null;

      // Temporary storage for an active session when navigating away (e.g., to wrong mode).
      // If not null, contains an object with sessionOrder, sessionCurrentIndex, sessionSize, sessionName and sessionWrong.
      let savedSessionState = null;

      function restoreTopActions() {
        topActionsEl.innerHTML = originalTopActionsHTML;
        // Show the update list when returning to the home page
        if (updateArea) {
          updateArea.classList.remove('hidden');
        }
      }
      
      topActionsEl.addEventListener('click', (event) => {
        const btn = event.target.closest('button');
        if (!btn) return;
        switch (btn.id) {
          case 'random50Btn': startFixedRandomSession(50); break;
          case 'random100Btn': startFixedRandomSession(100); break;
          case 'fullBtn': startFullPractice(); break;
          case 'historyBtn': showHistory(); break;
          case 'shuffleBtn': handleShuffle(); break;
          case 'exitSessionBtn': endSession(); break;
          case 'intervalSequentialBtn': handleIntervalPractice(false); break;
          case 'intervalRandomBtn': handleIntervalPractice(true); break;
          default: break;
        }
      });
      
      tabQuizBtn.addEventListener('click', () => {
        // If returning from a saved session (after viewing wrong or history), restore the session state
        if (savedSessionState) {
          const state = savedSessionState;
          mode = 'session';
          sessionOrder = state.sessionOrder.slice();
          sessionSize = state.sessionSize;
          sessionName = state.sessionName;
          sessionCurrentIndex = state.sessionCurrentIndex;
          sessionWrong = state.sessionWrong.slice();
          currentHistoryResumeIndex = state.historyIndex;
          savedSessionState = null;
          topActionsEl.innerHTML = `<span>当前模式: ${sessionName}</span><button id="exitSessionBtn">退出并保存到历史记录</button>`;
          tabQuizBtn.classList.add('active');
          tabWrongBtn.classList.remove('active');
          contentEl.classList.remove('hidden');
          // Hide update list during an active session
          if (updateArea) {
            updateArea.classList.add('hidden');
          }
          showCurrentQuestion();
        } else {
          // If no active session, switch to quiz tab normally
          if (mode !== 'quiz') {
            mode = 'quiz';
            tabQuizBtn.classList.add('active');
            tabWrongBtn.classList.remove('active');
            restoreTopActions();
            // Show update list on home page
            if (updateArea) {
              updateArea.classList.remove('hidden');
            }
            // Hide content when switching back to quiz area until a new session is started
            contentEl.classList.add('hidden');
            contentEl.innerHTML = '';
            progressEl.textContent = '';
          }
        }
      });
      tabWrongBtn.addEventListener('click', () => {
        // When a session is active, temporarily switch to wrong mode but preserve session state
        if (mode === 'session' || savedSessionState) {
          // Save the current session state if not already saved
          if (!savedSessionState) {
            savedSessionState = {
              sessionOrder: sessionOrder.slice(),
              sessionSize: sessionSize,
              sessionName: sessionName,
              sessionCurrentIndex: sessionCurrentIndex,
              sessionWrong: sessionWrong.slice(),
              historyIndex: currentHistoryResumeIndex
            };
          }
          mode = 'wrong';
          tabWrongBtn.classList.add('active');
          tabQuizBtn.classList.remove('active');
          // Keep the current session header and exit button visible
          topActionsEl.innerHTML = `<span>当前模式: ${sessionName}</span><button id="exitSessionBtn">退出并保存到历史记录</button>`;
          // Hide update list while in wrong mode
          if (updateArea) {
            updateArea.classList.add('hidden');
          }
          // Show wrong questions
          updateWrongOrder();
          wrongIndex = 0;
          contentEl.classList.remove('hidden');
          showCurrentQuestion();
        } else {
          // Normal transition to wrong tab (no active session)
          if (mode !== 'wrong') {
            mode = 'wrong';
            tabWrongBtn.classList.add('active');
            tabQuizBtn.classList.remove('active');
            restoreTopActions();
            // Hide update list while viewing wrong mode
            if (updateArea) {
              updateArea.classList.add('hidden');
            }
            // Show wrong questions immediately
            updateWrongOrder();
            wrongIndex = 0;
            if (wrongOrder.length === 0) {
              contentEl.innerHTML = '<p>没有错题～</p>';
              progressEl.textContent = '';
              contentEl.classList.remove('hidden');
            } else {
              contentEl.classList.remove('hidden');
              showCurrentQuestion();
            }
          }
        }
      });

      function handleShuffle() {
        // Shuffle behaviour depends on current mode.
        if (mode === 'session') {
          // Do not shuffle during an active session to avoid confusing order
          return;
        }
        if (mode === 'quiz') {
          // Shuffle the entire question set and start a full random session
          const indices = questions.map((_, idx) => idx);
          for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
          }
          startPracticeSession(indices, '随机打乱');
        } else if (mode === 'wrong') {
          // Shuffle only wrong questions in wrong mode and start a session on wrong questions
          updateWrongOrder();
          for (let i = wrongOrder.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [wrongOrder[i], wrongOrder[j]] = [wrongOrder[j], wrongOrder[i]];
          }
          if (wrongOrder.length > 0) {
            startPracticeSession(wrongOrder.slice(), '错题乱序');
          } else {
            contentEl.innerHTML = '<p>没有错题～</p>';
            progressEl.textContent = '';
            contentEl.classList.remove('hidden');
          }
        }
      }
      
      function handleIntervalPractice(isRandom) {
          const startStr = prompt("请输入起始题号:", "1");
          if (startStr === null) return;
          const endStr = prompt("请输入结束题号:", "50");
          if (endStr === null) return;
          const startNum = parseInt(startStr);
          const endNum = parseInt(endStr);
          const maxQuestionNum = questions[questions.length - 1].number;
          if (isNaN(startNum) || isNaN(endNum) || startNum < 1 || endNum > maxQuestionNum || startNum > endNum) {
              alert("输入的题号无效或范围不正确。请确保起始题号小于等于结束题号，且在 1 到 " + maxQuestionNum + " 之间。");
              return;
          }
          let indices = [];
          for (let i = 0; i < questions.length; i++) {
              if (questions[i].number >= startNum && questions[i].number <= endNum) {
                  indices.push(i);
              }
          }
          if(indices.length === 0){
              alert("在该范围内没有找到任何题目。");
              return;
          }
          if (isRandom) {
              for (let i = indices.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [indices[i], indices[j]] = [indices[j], indices[i]];
              }
          }
          const name = isRandom ? `区间随机 (${startNum}-${endNum})` : `区间顺序 (${startNum}-${endNum})`;
          startPracticeSession(indices, name);
      }

      function startFixedRandomSession(size) {
        const indices = questions.map((_, idx) => idx);
        for (let i = indices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [indices[i], indices[j]] = [indices[j], indices[i]];
        }
        const sessionIndices = indices.slice(0, size);
        startPracticeSession(sessionIndices, `随机${size}题`);
      }

      // Start a full practice session over the entire question set in sequential order.
      function startFullPractice() {
        const indices = questions.map((_, idx) => idx);
        startPracticeSession(indices, '完整刷题');
      }

      /**
       * Resume an incomplete practice session from history.
       * @param {number} historyIndex Index of the entry in sessionHistory
       */
      function resumeSession(historyIndex) {
        // Retrieve the entry from history
        const entry = sessionHistory[historyIndex];
        if (!entry) return;
        // Restore session parameters
        mode = 'session';
        sessionOrder = Array.isArray(entry.order) ? entry.order.slice() : [];
        // Fallback: if order is not stored, regenerate sequential indices
        if (sessionOrder.length === 0) {
          sessionOrder = questions.map((_, idx) => idx);
        }
        sessionSize = entry.size;
        sessionName = entry.mode;
        sessionCurrentIndex = entry.attempted || 0;
        sessionWrong = Array.isArray(entry.wrongQuestions) ? entry.wrongQuestions.slice() : [];
        currentHistoryResumeIndex = historyIndex;
        savedSessionState = null;
        // Render the practice header and show the content
        topActionsEl.innerHTML = `<span>当前模式: ${sessionName}</span><button id="exitSessionBtn">退出并保存到历史记录</button>`;
        contentEl.classList.remove('hidden');
        // Show the question corresponding to the saved current index
        showCurrentQuestion();
      }

      function startPracticeSession(indices, name) {
        // Start a new session. Reset resume index and saved state.
        currentHistoryResumeIndex = null;
        savedSessionState = null;
        mode = 'session';
        sessionOrder = indices;
        sessionSize = indices.length;
        sessionName = name;
        topActionsEl.innerHTML = `<span>当前模式: ${sessionName}</span><button id="exitSessionBtn">退出并保存到历史记录</button>`;
        // Hide updates during an active session
        if (updateArea) {
          updateArea.classList.add('hidden');
        }
        sessionCurrentIndex = 0;
        sessionWrong = [];
        // Show the content area and render the first question
        contentEl.classList.remove('hidden');
        showCurrentQuestion();
      }

      function endSession() {
        const wrongCount = sessionWrong.length;
        const attemptedCount = sessionCurrentIndex;
        // Save session history. If this session was resumed from history, update the existing entry, otherwise append a new entry.
        if (currentHistoryResumeIndex !== null) {
          const entry = sessionHistory[currentHistoryResumeIndex];
          entry.timestamp = Date.now();
          entry.mode = sessionName;
          entry.size = sessionSize;
          entry.attempted = attemptedCount;
          entry.wrongCount = wrongCount;
          entry.wrongQuestions = sessionWrong.slice();
          entry.order = sessionOrder.slice();
        } else {
          const entry = { timestamp: Date.now(), mode: sessionName, size: sessionSize, attempted: attemptedCount, wrongCount: wrongCount, wrongQuestions: sessionWrong.slice(), order: sessionOrder.slice() };
          sessionHistory.push(entry);
        }
        localStorage.setItem('plc1_sessionHistory', JSON.stringify(sessionHistory));
        // Reset resume index and clear any saved session state after finishing the session
        currentHistoryResumeIndex = null;
        savedSessionState = null;
        let summaryHtml = `<div class="session-summary"><h2>练习模式 “${sessionName}” 已结束</h2><p>作答情况：${attemptedCount} / ${sessionSize}</p><p>答错题数：${wrongCount}</p>`;
        if (wrongCount > 0) {
          summaryHtml += '<ul>';
          sessionWrong.forEach(item => {
            summaryHtml += `<li>题号${item.number}：正确答案 ${item.correctAnswer}（你的答案：${item.userAnswer}）</li>`;
          });
          summaryHtml += '</ul>';
        } else if (attemptedCount > 0) {
          summaryHtml += '<p>全部答对！</p>';
        }
        summaryHtml += '<button id="sessionReturnBtn">返回答题区</button> <button id="viewHistoryBtn">查看历史记录</button></div>';
        contentEl.innerHTML = summaryHtml;
        // Ensure the content area is visible for the summary
        contentEl.classList.remove('hidden');
        progressEl.textContent = '';
        document.getElementById('sessionReturnBtn').addEventListener('click', () => {
          // Return to quiz area but keep questions hidden until a new session begins
          mode = 'quiz';
          restoreTopActions();
          contentEl.classList.add('hidden');
          contentEl.innerHTML = '';
          progressEl.textContent = '';
        });
        document.getElementById('viewHistoryBtn').addEventListener('click', showHistory);
      }

      /**
       * NEW: Rerendered showHistory function
       */
      function showHistory() {
        mode = 'history';
        sessionHistory = JSON.parse(localStorage.getItem('plc1_sessionHistory') || '[]');
        topActionsEl.innerHTML = `<span>历史记录</span>`;
        progressEl.textContent = '';

        // Hide update list when viewing history
        if (updateArea) {
          updateArea.classList.add('hidden');
        }
        
        let html = '<div class="history-container">';
        
        if (!sessionHistory.length) {
          html += '<p>暂无刷题历史记录</p>';
        } else {
          html += `<div class="history-header"><h2>刷题历史记录</h2><button id="clearHistoryBtn" class="delete-btn">清除所有记录</button></div>`;
          sessionHistory.slice().reverse().forEach((entry, idx) => {
            const originalIndex = sessionHistory.length - 1 - idx;
            const date = new Date(entry.timestamp);
            const dateStr = date.toLocaleString('zh-CN');
            const attemptedText = entry.attempted !== undefined ? `答${entry.attempted}题` : '';
            const resultText = `错${entry.wrongCount}题`;

            html += `
              <div class="history-entry">
                <details>
                  <summary>
                    <div class="summary-info">
                      <span class="info-main">${entry.mode}</span>
                      <span class="info-sub">${dateStr} | ${attemptedText} | ${resultText}</span>
                    </div>
                    <button class="delete-btn delete-single-btn" data-index="${originalIndex}">删除</button>
                  </summary>
                  <div class="history-details">`;
            
            if (entry.wrongCount > 0) {
              html += '<ul>';
              entry.wrongQuestions.forEach(item => {
                html += `<li>题号${item.number}：正确答案 ${item.correctAnswer}（你的答案：${item.userAnswer}）</li>`;
              });
              html += '</ul>';
            } else if (entry.attempted > 0) {
              html += '<p>全部答对！</p>';
            } else {
              html += '<p>未作答题目。</p>';
            }
            // If the session is incomplete, provide a resume button to continue from where the user left off
            if (entry.attempted < entry.size) {
              html += `<p><button class="resume-btn" data-index="${originalIndex}">继续练习</button></p>`;
            }
            html += '</div></details></div>';
          });
        }
        html += '<button id="historyBackBtn">返回答题区</button></div>';
        contentEl.innerHTML = html;
        // Ensure history content is visible
        contentEl.classList.remove('hidden');

        // Add event listeners for new buttons
        const historyContainer = contentEl.querySelector('.history-container');
        if (historyContainer) {
            historyContainer.addEventListener('click', function(event) {
                // Handle single delete
                if (event.target.classList.contains('delete-single-btn')) {
                    event.preventDefault();
                    event.stopPropagation();
                    const indexToDelete = parseInt(event.target.dataset.index, 10);
                    if (confirm('您确定要删除这条记录吗？')) {
                        sessionHistory.splice(indexToDelete, 1);
                        localStorage.setItem('plc1_sessionHistory', JSON.stringify(sessionHistory));
                        showHistory(); // Refresh view
                    }
                    return;
                }
                // Handle clear all
                if (event.target.id === 'clearHistoryBtn') {
                    if (confirm('您确定要清除所有历史记录吗？此操作无法撤销。')) {
                        sessionHistory = [];
                        localStorage.removeItem('plc1_sessionHistory');
                        showHistory(); // Refresh view
                    }
                    return;
                }
                // Handle resume button
                if (event.target.classList.contains('resume-btn')) {
                    event.preventDefault();
                    event.stopPropagation();
                    const idx = parseInt(event.target.dataset.index, 10);
                    resumeSession(idx);
                    return;
                }
            });
        }
        
        document.getElementById('historyBackBtn').addEventListener('click', () => {
          // Return to quiz area but keep questions hidden until a new session begins
          mode = 'quiz';
          restoreTopActions();
          contentEl.classList.add('hidden');
          contentEl.innerHTML = '';
          progressEl.textContent = '';
        });
      }

      function showCurrentQuestion() {
        let qIndex;
        if (mode === 'quiz') {
          if (order.length === 0) return;
          currentIndex = Math.max(0, Math.min(currentIndex, order.length - 1));
          qIndex = order[currentIndex];
        } else if (mode === 'wrong') {
          updateWrongOrder();
          if (wrongOrder.length === 0) {
            contentEl.innerHTML = '<p>没有错题～</p>';
            progressEl.textContent = '';
            return;
          }
          wrongIndex = Math.max(0, Math.min(wrongIndex, wrongOrder.length - 1));
          qIndex = wrongOrder[wrongIndex];
        } else if (mode === 'session') {
          if (sessionCurrentIndex >= sessionOrder.length) {
            endSession();
            return;
          }
          qIndex = sessionOrder[sessionCurrentIndex];
        } else {
          return;
        }
        const q = questions[qIndex];
        let total, currentPos;
        if (mode === 'quiz') { total = order.length; currentPos = currentIndex + 1; }
        else if (mode === 'wrong') { total = wrongOrder.length; currentPos = wrongIndex + 1; }
        else if (mode === 'session') { total = sessionOrder.length; currentPos = sessionCurrentIndex + 1; }
        
        const displayType = (q.options.length === 0) ? '判断' : q.type;
        progressEl.textContent = `【${displayType}】【${currentPos}/${total}】`;
        wrongCounts = JSON.parse(localStorage.getItem('plc1_wrongCounts') || '{}');
        const wrongCount = wrongCounts[q.number] || 0;
        let html = `<div class="question-container"><div class="question-header">${wrongCount > 0 ? `<span class="badge">已错 ${wrongCount} 次</span>` : ''}<span>${q.question}</span></div><div class="options">`;
        let inputType;
        if (q.options.length === 0) {
          inputType = 'radio';
          [{ value: 'T', label: '正确' }, { value: 'F', label: '错误' }].forEach(opt => {
            html += `<div class="option"><label><input type="${inputType}" name="answer" value="${opt.value}"> ${opt.label}</label></div>`;
          });
        } else {
          inputType = (q.type === '多选') ? 'checkbox' : 'radio';
          q.options.forEach(opt => {
            let text = (opt.text || '').trim() || '（空）';
            html += `<div class="option"><label><input type="${inputType}" name="answer" value="${opt.label}"> ${opt.label}、${text}</label></div>`;
          });
        }
        html += `</div><div class="buttons"><button id="prevBtn" class="hidden">上一题</button><button id="retryBtn" class="hidden">再试一次</button><button id="submitBtn">提交答案</button><button id="nextBtn" class="hidden">下一题</button><button id="removeWrongBtn" class="hidden">从错题本中移除</button></div><div id="feedback" class="feedback"></div></div>`;
        contentEl.innerHTML = html;
        const submitBtn = document.getElementById('submitBtn'), retryBtn = document.getElementById('retryBtn'), prevBtn = document.getElementById('prevBtn'), nextBtn = document.getElementById('nextBtn'), removeWrongBtn = document.getElementById('removeWrongBtn');
        
        submitBtn.addEventListener('click', () => handleSubmit(q, inputType, submitBtn, retryBtn, nextBtn, removeWrongBtn));
        retryBtn.addEventListener('click', showCurrentQuestion);
        nextBtn.addEventListener('click', () => {
          if (mode === 'quiz') {
            currentIndex++;
            if (currentIndex >= order.length) currentIndex = 0;
          } else if (mode === 'wrong') {
            wrongIndex++;
            if (wrongIndex >= wrongOrder.length) wrongIndex = 0;
          } else if (mode === 'session') {
            sessionCurrentIndex++;
            // When resuming from history, persist progress to the history entry
            if (currentHistoryResumeIndex !== null) {
              const resumeEntry = sessionHistory[currentHistoryResumeIndex];
              resumeEntry.attempted = sessionCurrentIndex;
              resumeEntry.wrongCount = sessionWrong.length;
              resumeEntry.wrongQuestions = sessionWrong.slice();
              resumeEntry.order = sessionOrder.slice();
              localStorage.setItem('plc1_sessionHistory', JSON.stringify(sessionHistory));
            }
          }
          showCurrentQuestion();
        });
        removeWrongBtn.addEventListener('click', () => {
          delete wrongCounts[q.number];
          localStorage.setItem('plc1_wrongCounts', JSON.stringify(wrongCounts));
          removeWrongBtn.textContent = '已移除';
          removeWrongBtn.disabled = true;
        });

        // Handle previous question navigation
        if (prevBtn) {
          prevBtn.addEventListener('click', () => {
            if (mode === 'quiz') {
              if (currentIndex > 0) {
                currentIndex--;
              }
            } else if (mode === 'wrong') {
              if (wrongIndex > 0) {
                wrongIndex--;
              }
            } else if (mode === 'session') {
              if (sessionCurrentIndex > 0) {
                sessionCurrentIndex--;
              }
            }
            showCurrentQuestion();
          });
          // Show or hide previous button based on current position
          let showPrev = false;
          if (mode === 'quiz') {
            showPrev = (currentIndex > 0);
          } else if (mode === 'wrong') {
            showPrev = (wrongIndex > 0);
          } else if (mode === 'session') {
            showPrev = (sessionCurrentIndex > 0);
          }
          if (showPrev) {
            prevBtn.classList.remove('hidden');
          } else {
            prevBtn.classList.add('hidden');
          }
        }
      }

      function handleSubmit(q, inputType, submitBtn, retryBtn, nextBtn, removeWrongBtn) {
        const selected = Array.from(contentEl.querySelectorAll('input[name="answer"]:checked'));
        if (selected.length === 0) { alert('请选择答案后再提交'); return; }
        const userAnswers = selected.map(el => el.value).sort();
        let correct = false;
        let correctDisplay;
        if (q.options.length === 0) {
          const isTrueAnswer = !q.answer.some(ans => ans.trim().includes('错') || ans.trim().includes('误'));
          const expected = isTrueAnswer ? 'T' : 'F';
          correct = (userAnswers.length === 1 && userAnswers[0] === expected);
          correctDisplay = isTrueAnswer ? '正确' : '错误';
        } else {
          const correctAnswers = q.answer.slice().sort();
          correct = (userAnswers.length === correctAnswers.length && userAnswers.every((v, i) => v === correctAnswers[i]));
          correctDisplay = q.answer.join('');
        }
        submitBtn.disabled = true;
        const feedbackEl = document.getElementById('feedback');
        if (correct) {
          feedbackEl.textContent = '回答正确！';
          feedbackEl.className = 'feedback correct';
          nextBtn.classList.remove('hidden');
          retryBtn.classList.add('hidden');
          if (mode === 'wrong') {
            removeWrongBtn.classList.remove('hidden');
          }
        } else {
          wrongCounts[q.number] = (wrongCounts[q.number] || 0) + 1;
          localStorage.setItem('plc1_wrongCounts', JSON.stringify(wrongCounts));
          feedbackEl.textContent = '回答错误！正确答案：' + correctDisplay;
          feedbackEl.className = 'feedback incorrect';
          retryBtn.classList.remove('hidden');
          nextBtn.classList.remove('hidden');
          if (mode === 'session' && !sessionWrong.some(item => item.number === q.number)) {
            sessionWrong.push({ number: q.number, correctAnswer: correctDisplay, userAnswer: userAnswers.join('') });
            // When resuming from history, update wrong counts immediately
            if (currentHistoryResumeIndex !== null) {
              const resumeEntry = sessionHistory[currentHistoryResumeIndex];
              resumeEntry.wrongCount = sessionWrong.length;
              resumeEntry.wrongQuestions = sessionWrong.slice();
              localStorage.setItem('plc1_sessionHistory', JSON.stringify(sessionHistory));
            }
          }
        }
      }
      // 初始化：仅显示顶部操作和签名，隐藏题目区域
      restoreTopActions();
      contentEl.classList.add('hidden');
      contentEl.innerHTML = '';
      progressEl.textContent = '';
    })();
  </script>
</body>
</html>
